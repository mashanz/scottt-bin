#!/usr/bin/env python

compilefunc_usage = (
'''usage: compilefunc [options] SOURCE-FILE FUNCTION [FUNCTION...]
Generate assembler output on stdout for specified functions.
Supports the CC, CFLAGS, CXX, CXXFLAGS, LDFLAGS and GDB environment variables.
Unknown options are passed to the compiler.
Invokes gcc or g++ depending on the file extension.

NOTE: unless --do-link is passed, global variable and function references
will appear to reference the wrong address.
''')

gdbdis_usage = (
'''usage: gdbdis EXE FUNC
Disassemble a funtion from an executable with GDB
        $ gdbdis /bin/true main
        0x00000000004011b0 <+0>: 83 ff 02    cmp    $0x2,%edi
        0x00000000004011b3 <+3>: 53          push   %rbx
''')

gdbx_usage = (
'''usage: gdbx EXE ADDR FORMAT
Examine a memory address with GDB from an executable
        $ gdbx /bin/true 0x4039e4 s
        0x4039e4 <__dso_handle+732>:   "GNU coreutils"
''')

import sys
import os
import subprocess
import errno
import argparse
import tempfile
import logging

main_function_map = {}

def main_function(func):
    global main_function_map
    main_function_map[func.__name__.replace('_','-')] = func
    return func

def main_function_dispatch(name, args):
    try:
        f = main_function_map[name]
    except KeyError:
        sys.stderr.write('%s is not a valid command name\n' % (name,))
        sys.exit(2)
    f(args)

def program_name():
    return os.path.basename(sys.argv[0])

def gdb_batch_disassemble(gdb, exe, functions, options):
    t = tempfile.NamedTemporaryFile(mode='w+')
    t.write('file %s\n' % (exe,))
    if options.raw_instructions or options.source:
        dis_options = '/'
    else:
        dis_options = ''
    if options.raw_instructions:
        dis_options += 'r'
    if options.source:
        dis_options += 'm'

    for i in functions:
        t.write('disassemble %s %s\n' % (dis_options, i))
    t.seek(0)

    (outfile, errfile) = (tempfile.TemporaryFile(mode='w+'), tempfile.TemporaryFile(mode='w+'))
    subprocess.call([gdb, '--batch', '-x', t.name], stdout=outfile, stderr=errfile)
    # NOTE: gdb exits with 0 even on errors ...
    # Let's hope these GDB error message strings are stable ..
    errfile.seek(0)
    errlines = [ x for x in errfile.readlines() ]
    if errlines:
        sys.stderr.write('%s input:\n' % (gdb,))
        t.seek(0)
        sys.stderr.write(t.read())
        sys.stderr.write('\n%s stderr:\n' % (gdb,))
        # errlines[0] would be 't.gdb:2: Error in sourced command file:'
        sys.stderr.writelines(errlines[1:])
        raise ValueError

    outfile.seek(0)
    o = outfile.read()

    if not options.no_header:
        sys.stdout.write(o)
        return

    (start, end) = (-1, 0)
    while 1:
        start = o.find('Dump of assembler code for function ', start + 1)
        if start == -1:
            break
        start = o.find('\n', start) + 1
        end = o.find('End of assembler dump.\n', start)
        assert(end != -1)
        sys.stdout.write(o[start:end])

def gdb_command_name():
    cc = os.environ.get('CC', 'gcc')
    gdb = os.environ.get('GDB')
    if gdb is None:
        # 'arm-linux-androideabi-gcc' -> 'arm-linux-androideabi-gdb'
        try:
            gdb = cc[:cc.rindex('-')+1]+'gdb'
        except ValueError:
            gdb = 'gdb'
    return gdb

@main_function
def compilefunc(args):
    ap = argparse.ArgumentParser(description='generate asm for the specified functions')
    ap.add_argument('source_file', metavar='SOURCE-FILE', help='C or C++ source file')
    ap.add_argument('functions', metavar='FUNCTION', nargs='+', help='function to generate asm for')
    ap.add_argument('--do-link', action='store_true', help='link and not just compile the code')
    ap.add_argument('--source', action='store_true', help='generate mixed source and asm output')
    ap.add_argument('--raw-instructions', action='store_true',
                    help='show instruction encodings in hex next to asm')
    (args, unknown_args) = ap.parse_known_args(args)
    if len(args.functions) < 2:
        args.no_header = True
    else:
        args.no_header = False

    t = args.source_file
    if t.endswith('.cpp') or t.endswith('.cc'):
        (env_cc, default_cc, env_cflags) = ('CXX', 'g++', 'CXXFLAGS')
    else:
        (env_cc, default_cc, env_cflags) = ('CC', 'gcc', 'CFLAGS')
    cc = os.environ.get(env_cc, default_cc)
    cflags = os.environ.get(env_cflags, '')
    cflags = [ x for x in cflags.split() if x ]
    gdb = gdb_command_name()

    (fout_fd, fout) = tempfile.mkstemp()
    t = ['-g']
    if args.do_link:
        ldflags = os.environ.get('LDFLAGS', '')
        ldflags = [ x for x in ldflags.split() if x ]
        t.extend([ args.source_file ] + ldflags)
    else:
        t.extend([ '-c', args.source_file ])
    try:
        cmd = [cc] + cflags  + unknown_args + t + ['-o', fout]
        logging.debug('compile: %s' % (cmd,))
        r = subprocess.call(cmd)
        if r == 0:
            try:
                gdb_batch_disassemble(gdb, fout, args.functions, args)
            except ValueError:
                sys.exit(3)
    finally:
        os.unlink(fout)

@main_function
def gdbdis(args):
    ap = argparse.ArgumentParser(description='disassemble function from EXE')
    ap.add_argument('executable', metavar='EXECUTABLE', help='executable file to disassemble')
    ap.add_argument('functions', metavar='FUNCTION', nargs='+', help='function name or address to disassemble')
    ap.add_argument('-r', '--raw-instructions', action='store_true', help='show raw instruction opcodes')
    ap.add_argument('-s', '--source', action='store_true', help='include source lines'),
    ap.add_argument('--no-header', action='store_true', 
                        help="don't show \"Dump of ...\" headers and footers even when disassembling multiple functions")
    (args, unknown_args) = ap.parse_known_args(args)

    if len(args.functions) == 1:
        args.no_header = True

    gdb = gdb_command_name()
    gdb_batch_disassemble(gdb, args.executable, args.functions, args)

if __name__ == '__main__':
    main_function_dispatch(program_name(), sys.argv[1:])
